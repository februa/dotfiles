[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc'
build = 'make'
hook_source = '''
if has('win64')
    let g:vimproc#download_windows_dll = 1
endif
'''

[[plugins]] # カーソル位置のコンテキストに合わせてftを切り替える
repo = 'osyo-manga/vim-precious'
depends = ['context_filetype.vim']

[[plugins]] # カーソル位置のコンテキストのftを判定するライブラリ
repo = 'Shougo/context_filetype.vim'
[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
let g:ale_fixers = {
\   '*': ['remove_trailing_lines', 'trim_whitespace'],
\   'python': ['autopep8', 'black', 'isort'],
\   'tex': ['textlint'],
\}
let g:ale_linters = {
 \  'tex': ['textlint']
 \}
" Set this variable to 1 to fix files when you save them.
let g:ale_fix_on_save = 1
let g:ale_sign_column_always = 1
" エラー行にカーソルをあわせた際に表示されるメッセージフォーマット
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
" エラー表示の列を常時表示
let g:ale_sign_column_always = 1

" ファイルを開いたときにlint実行
let g:ale_lint_on_enter = 1
" ファイルを保存したときにlint実行
let g:ale_lint_on_save = 1

" lint結果をロケーションリストとQuickFixには表示しない
" 出てると結構うざいしQuickFixを書き換えられるのは困る
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 0
let g:ale_open_list = 0
let g:ale_keep_list_window_open = 0
'''

[[plugins]]
repo = 'kassio/neoterm'
hook_add = '''
cnoremap (keymapping) T (command)<CR>
cnoremap (keymapping) T (command)<CR><C-w>j
'''
[[plugins]]
repo = 'tyru/caw.vim'
hook_add = '''
" 行の最初の文字の前にコメント文字をトグル
nmap <Leader>, <Plug>(caw:hatpos:toggle)
vmap <Leader>, <Plug>(caw:hatpos:toggle)
" 行頭にコメントをトグル
nmap <Leader>c <Plug>(caw:zeropos:toggle)
vmap <Leader>c <Plug>(caw:zeropos:toggle)
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
on_ft = ['python','tex']
hook_add = '''
" vimprocで非同期実行
" 成功時にバッファ、失敗時にQuickFixで表示
" 結果表示のサイズ調整など
let g:quickrun_config = {
    \ '_' : {
        \ 'runner' : 'vimproc',
        \ 'runner/vimproc/updatetime' : 40,
        \ 'outputter' : 'error',
        \ 'outputter/error/success' : 'buffer',
        \ 'outputter/error/error'   : 'quickfix',
        \ 'outputter/buffer/split' : ':botright 8sp',
    \ }
\}

" 実行時に前回の表示内容をクローズ&保存してから実行
let g:quickrun_no_default_key_mappings = 1
nmap <Leader>r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
'''
# Toml
[[plugins]]
repo  = 'cespare/vim-toml'
on_ft = 'toml'

# vim-autoclose
[[plugins]]
repo = 'Townk/vim-autoclose'

[[plugins]]
repo = 'lilydjwg/fcitx.vim'
if = '''has('unix')'''
on_ft = ['tex','text']

# vim-autosave
[[plugins]]
repo = 'vim-scripts/vim-auto-save'
hook_add = '''
let g:auto_save = 1
let g:auto_save_in_insert_mode = 0
let g:auto_save_no_updatetime = 1
let g:auto_save_silent = 1
'''
# NERD Tree {{{
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
let g:NERDTreeShowBookmarks=1
nnoremap <C-n> :NERDTreeToggle<CR>
" Auto-close nerdtree window
autocmd MyAutoCmd WinEnter * if (winnr('$') == 1) && (&filetype == 'nerdtree') | quit | endif
'''
# }}}
# denite nvim {{{
[[plugins]]
repo = 'Shougo/denite.nvim'
on_event = 'BufRead'
hook_add = '''
"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> sN :<C-u>DeniteBufferDir
      \ -direction=topleft -cursor-wrap=true file file:new<CR>
"バッファ一覧
nnoremap <silent> sP :<C-u>Denite -direction=topleft -cursor-wrap=true buffer<CR>
"最近使用したファイル一覧
nnoremap <silent> sm :<C-u>Denite -direction=topleft -cursor-wrap=true file_mru<CR>

let s:denite_win_width_percent = 0.8
let s:denite_win_height_percent = 0.6

'''
hook_post_source = '''
if !dein#check_install('denite.nvim')
    " Change denite default options
    call denite#custom#option('default', {
        \ 'split': 'floating',
        \ 'winwidth': &columns * s:denite_win_width_percent,
        \ 'wincol': (&columns - (&columns * s:denite_win_width_percent)) / 2,
        \ 'winheight': &lines * s:denite_win_height_percent,
        \ 'winrow': (&lines - (&lines * s:denite_win_height_percent)) / 2,
        \ })
    call denite#custom#source('file'    , 'matchers', ['matcher_cpsm', 'matcher_fuzzy'])

    call denite#custom#source('buffer'  , 'matchers', ['matcher_regexp'])
    call denite#custom#source('file_mru', 'matchers', ['matcher_regexp'])

    call denite#custom#alias('source', 'file_rec/git', 'file_rec')
    call denite#custom#var('file_rec/git', 'command',
    \ ['git', 'ls-files', '-co', '--exclude-standard'])

    call denite#custom#map('insert', '<C-N>', '<denite:move_to_next_line>', 'noremap')
    call denite#custom#map('insert', '<C-P>', '<denite:move_to_previous_line>', 'noremap')
    call denite#custom#map('insert', '<C-W>', '<denite:move_up_path>', 'noremap')
endif
'''
[[plugins]]
repo = 'nixprime/cpsm'
build = 'env PY3=ON ./install.sh'
[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
nmap <silent> gs :<C-u>Gstatus<CR>
nmap <silent> gd :<C-u>Gdiff<CR>
nmap <silent> gb :<C-u>Gblame<CR>
nmap <silent> gl :<C-u>Glog<CR>
'''
[[plugins]]
repo = 'airblade/vim-gitgutter'
[[plugins]]
repo = 'Shougo/neomru.vim'
# }}}
# LeafCage/foldCC {{{
[[plugins]]
repo = 'LeafCage/foldCC'
hook_add = '''set foldtext=FoldCCtext()'''
# }}}
# lightline.vim {{{
[[plugins]] repo = 'itchyny/lightline.vim'
hook_add = '''
let g:lightline = {
      \'colorscheme': 'nord',
      \'active': {
            \'left': [['prepare', 'mode', 'filename'], ['fugitive']],
            \'right': [['lineinfo'], ['fileinfo'], ['ale']]},
      \'component_visible_condition': {
            \'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'},
      \'component_function': {
            \'prepare': 'LLPrepare',
            \'mode': 'LLMode',
            \'filename': 'LLFileName',
            \'fugitive': 'LLFugitive',
            \'fileinfo': 'LLFileInfo',
            \'lineinfo': 'LLLineInfo',
            \'ale': 'LLAle',
            \},
      \ 'separator': { 'left': '', 'right': '' },
      \ 'subseparator': { 'left': '', 'right': '' }
      \}
let g:lightline.inactive = g:lightline.active
let g:lightline.tab = {
      \ 'active': [ 'tabnum', 'filename', 'modified' ],
      \ 'inactive': [ 'tabnum', 'filename', 'modified' ]
      \ }

let g:lightline.tab_component_function = {
      \ 'filename': 'LLTabFilename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum' }

function! LLTabFilename(n) abort
  let buflist = tabpagebuflist(a:n)
  let winnr = tabpagewinnr(a:n)
  let _ = pathshorten(expand('#'.buflist[winnr - 1].':f'))
  return _ !=# '' ? _ : '[No Name]'
endfunction

function! LLPrepare()
  let g:ll_mode = ''
  let g:ll_filename = ''
  let g:ll_fugitive = ''
  let g:ll_lineinfo = ''
  let g:ll_ale = ''

  let l:ww = winwidth('.')
  let l:total_len = 0

  let g:ll_mode = lightline#mode() . (&paste ? ' P' : '')
  if g:ll_mode !=# ''
    let l:total_len += strlen(g:ll_mode) + 2
    if l:ww < l:total_len
      return ''
    endif
  endif

  let g:ll_lineinfo = printf('%d/%d:%d', line('.'), line('$'), col('.'))
  if g:ll_lineinfo !=# ''
    let l:total_len += strlen(g:ll_lineinfo) + 2
    if l:ww < l:total_len
      let g:ll_lineinfo = ''
      return ''
    endif
  endif

  let g:ll_filename = expand('%:t') . (&filetype !~? 'help' && &readonly ? ' RO' : '') . (&modifiable && &modified ? ' +' : '')
  if g:ll_filename !=# ''
    let l:total_len += strlen(g:ll_filename) + 2
    if l:ww < l:total_len
      let g:ll_filename = ''
      return ''
    endif
  endif

  let g:ll_fileinfo = &fileformat . ' ' . (strlen(&fileencoding) ? &fileencoding : &encoding) . ' ' . (strlen(&filetype) ? &filetype : 'no')
  if g:ll_fileinfo !=# ''
    let l:total_len += strlen(g:ll_fileinfo) + 2
    if l:ww < l:total_len
      let g:ll_fileinfo = ''
      return ''
    endif
  endif

  let g:ll_ale = LLGetAle()
  if g:ll_ale !=# ''
    let l:total_len += strlen(g:ll_ale) + 2
    if l:ww < l:total_len
      let g:ll_ale = ''
      return ''
    endif
  endif

  let g:ll_fugitive = exists('*fugitive#head') ? fugitive#head() : ''
  if g:ll_fugitive !=# ''
    let l:total_len += strlen(g:ll_fugitive) + 2
    if l:ww < l:total_len
      let g:ll_fugitive = ''
      return ''
    endif
  endif

  return ''
endfunction

function! LLMode()
  return g:ll_mode
endfunction

function! LLFileName()
  return g:ll_filename
endfunction

function! LLFugitive()
  return g:ll_fugitive
endfunction

function! LLFileInfo()
  return g:ll_fileinfo
endfunction

function! LLLineInfo()
  return g:ll_lineinfo
endfunction

function! LLAle()
  return g:ll_ale
endfunction

if dein#tap('ale')
  function! LLGetAle()
    let l:count = ale#statusline#Count(bufnr(''))
    let l:errors = l:count.error + l:count.style_error
    let l:warnings = l:count.warning + l:count.style_warning
    return l:count.total == 0 ? 'OK' : 'E:' . l:errors . ' W:' . l:warnings
  endfunction
else
  function! LLGetAle()
    return ''
  endfunction
endif
'''
# }}}
