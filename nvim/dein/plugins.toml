[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc'
build = 'make'
hook_source = '''
if has('win64')
    let g:vimproc#download_windows_dll = 1
endif
'''


[[plugins]]
repo = 'kassio/neoterm'
hook_add = '''
cnoremap (keymapping) T (command)<CR>
cnoremap (keymapping) T (command)<CR><C-w>j
'''
[[plugins]]
repo = 'tyru/caw.vim'
hook_add = '''
" 行の最初の文字の前にコメント文字をトグル
nmap <Leader>, <Plug>(caw:hatpos:toggle)
vmap <Leader>, <Plug>(caw:hatpos:toggle)
" 行頭にコメントをトグル
nmap <Leader>c <Plug>(caw:zeropos:toggle)
vmap <Leader>c <Plug>(caw:zeropos:toggle)
'''

# vim-autoclose
[[plugins]]
repo = 'Townk/vim-autoclose'

# vim-autosave {{{
[[plugins]]
repo = 'vim-scripts/vim-auto-save'
hook_add = '''
let g:auto_save = 1
let g:auto_save_in_insert_mode = 0
let g:auto_save_no_updatetime = 1
let g:auto_save_silent = 1
'''
# }}}
# vim-surround {{{
[[plugins]]
repo = 'tpope/vim-surround'
# 使用可能な引用符など',",[],{},(),その他htmlタグ
# example: 選択した部分を変更する
# S' : 選択したテキストを'で囲む
# S<b> : 選択したテキストを<b>で囲む
# example: 'や{の間にカーソルがある時
# ds': カーソル前後の''を消す
# dst: htmlタグを消す
# cs'": カーソル前後の''を""に置換する
# cs"<b>: カーソル前後の""を<b>に置換する
# example: ノーマルモードでテキスト選択と置換
# ysaw(: 1単語を()で囲む
# This is 'a surrounded text'. -> This is 'a ( surrounded ) text'.
# ysi'(:
# This is 'a surrounded text'. -> This is '( a surrounded text )'.
# ysa'(: This is 'a surrounded text'. -> This is( 'a surrounded text' ).
# }}}
# ale {{{
[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
let g:ale_fixers = {
\   '*': ['trim_whitespace'],
\   'python': ['autopep8', 'black', 'isort'],
\   'tex': ['textlint'],
\}
let g:ale_linters = {
 \  'tex': ['textlint']
 \}
" Set this variable to 1 to fix files when you save them.
let g:ale_fix_on_save = 1
let g:ale_sign_column_always = 1
" エラー行にカーソルをあわせた際に表示されるメッセージフォーマット
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
" エラー表示の列を常時表示
let g:ale_sign_column_always = 1

" ファイルを開いたときにlint実行
let g:ale_lint_on_enter = 1
" ファイルを保存したときにlint実行
let g:ale_lint_on_save = 1

" lint結果をロケーションリストとQuickFixには表示しない
" 出てると結構うざいしQuickFixを書き換えられるのは困る
" let g:ale_set_loclist = 0
" let g:ale_set_quickfix = 0
" let g:ale_open_list = 0
" let g:ale_keep_list_window_open = 0
'''
# }}}
# NERD Tree {{{
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
let g:NERDTreeShowBookmarks=1
let g:NERDTreeShowHidden=1
let g:NERDTreeQuitOnOpen=1
let g:NERDTreeIgnore=['\.git$', '\.clean$', '\.swp$', '\.bak$', '\~$']
nnoremap <C-n> :NERDTreeToggle<CR>
" Auto-close nerdtree window
autocmd MyAutoCmd WinEnter * if (winnr('$') == 1) && (&filetype == 'nerdtree') | quit | endif
'''
# }}}
# denite nvim {{{
[[plugins]]
repo = 'Shougo/denite.nvim'
on_event = 'BufRead'
hook_add = '''
"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> sN :<C-u>DeniteBufferDir
      \ -direction=topleft -cursor-wrap=true file file:new<CR>
"バッファ一覧
nnoremap <silent> sP :<C-u>Denite -direction=topleft -cursor-wrap=true buffer<CR>
"最近使用したファイル一覧
nnoremap <silent> sm :<C-u>Denite -direction=topleft -cursor-wrap=true file_mru<CR>

let s:denite_win_width_percent = 0.8
let s:denite_win_height_percent = 0.6
" Change denite default options
call denite#custom#option('default', {
    \ 'split': 'floating',
    \ 'winwidth': &columns * s:denite_win_width_percent,
    \ 'wincol': (&columns - (&columns * s:denite_win_width_percent)) / 2,
    \ 'winheight': &lines * s:denite_win_height_percent,
    \ 'winrow': (&lines - (&lines * s:denite_win_height_percent)) / 2,
    \ })

'''
hook_post_source = '''
if !dein#check_install('denite.nvim')
    call denite#custom#source('file'    , 'matchers', ['matcher_cpsm', 'matcher_fuzzy'])

    call denite#custom#source('buffer'  , 'matchers', ['matcher_regexp'])
    call denite#custom#source('file_mru', 'matchers', ['matcher_regexp'])

    call denite#custom#alias('source', 'file_rec/git', 'file_rec')
    call denite#custom#var('file_rec/git', 'command',
    \ ['git', 'ls-files', '-co', '--exclude-standard'])

    call denite#custom#map('insert', '<C-N>', '<denite:move_to_next_line>', 'noremap')
    call denite#custom#map('insert', '<C-P>', '<denite:move_to_previous_line>', 'noremap')
    call denite#custom#map('insert', '<C-W>', '<denite:move_up_path>', 'noremap')
endif
'''
[[plugins]]
repo = 'nixprime/cpsm'
build = 'env PY3=ON ./install.sh'
[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
nmap <silent> gs :<C-u>Gstatus<CR>
nmap <silent> gd :<C-u>Gdiff<CR>
nmap <silent> gb :<C-u>Gblame<CR>
nmap <silent> gl :<C-u>Glog<CR>
'''
[[plugins]]
repo = 'airblade/vim-gitgutter'
[[plugins]]
repo = 'Shougo/neomru.vim'
# }}}
# LeafCage/foldCC {{{
[[plugins]]
repo = 'LeafCage/foldCC'
hook_add = '''set foldtext=FoldCCtext()'''
# }}}
# lightline.vim {{{
[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
set showtabline=2  " always show tabline
" remap arrow keys
nnoremap <Left> :bprev<CR>
nnoremap <Right> :bnext<CR>
let g:lightline = {
      \'colorscheme': 'nord',
      \'active': {
      \'left':  [ ['prepare', 'mode', 'filename'],
      \           ['fugitive']
      \         ],
      \'right': [ ['lineinfo'],
      \           ['fileinfo'],
      \           ['ale']
      \         ]
      \ },
      \ 'tabline': {
      \   'left': [ [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
      \ },
      \ 'component_visible_condition': {
            \'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'},
      \ 'component_expand': {
      \   'buffercurrent': 'lightline#buffer#buffercurrent',
      \   'bufferbefore': 'lightline#buffer#bufferbefore',
      \   'bufferafter': 'lightline#buffer#bufferafter',
      \ },
      \ 'component_type': {
      \   'buffercurrent': 'tabsel',
      \   'bufferbefore': 'raw',
      \   'bufferafter': 'raw',
      \ },
      \ 'component_function': {
      \    'prepare': 'LLPrepare',
      \    'mode': 'LLMode',
      \    'filename': 'LLFileName',
      \    'fugitive': 'LLFugitive',
      \    'fileinfo': 'LLFileInfo',
      \    'lineinfo': 'LLLineInfo',
      \    'ale': 'LLAle',
      \    'bufferinfo': 'lightline#buffer#bufferinfo',
      \ },
      \ 'component': {
      \   'separator': '',
      \ },
      \ 'separator': { 'left': '', 'right': '' },
      \ 'subseparator': { 'left': '', 'right': '' }
      \}
let g:lightline.inactive = g:lightline.active
let g:lightline.tab = {
      \ 'active': [ 'tabnum', 'filename', 'modified' ],
      \ 'inactive': [ 'tabnum', 'filename', 'modified' ]
      \ }

let g:lightline.tab_component_function = {
      \ 'filename': 'LLTabFilename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum' }

function! LLTabFilename(n) abort
  let buflist = tabpagebuflist(a:n)
  let winnr = tabpagewinnr(a:n)
  let _ = pathshorten(expand('#'.buflist[winnr - 1].':f'))
  return _ !=# '' ? _ : '[No Name]'
endfunction

function! LLPrepare()
  let g:ll_mode = ''
  let g:ll_filename = ''
  let g:ll_fugitive = ''
  let g:ll_lineinfo = ''
  let g:ll_ale = ''

  let l:ww = winwidth('.')
  let l:total_len = 0

  let g:ll_mode = lightline#mode() . (&paste ? ' P' : '')
  if g:ll_mode !=# ''
    let l:total_len += strlen(g:ll_mode) + 2
    if l:ww < l:total_len
      return ''
    endif
  endif

  let g:ll_lineinfo = printf('%d/%d:%d', line('.'), line('$'), col('.'))
  if g:ll_lineinfo !=# ''
    let l:total_len += strlen(g:ll_lineinfo) + 2
    if l:ww < l:total_len
      let g:ll_lineinfo = ''
      return ''
    endif
  endif

  let g:ll_filename = expand('%:t') . (&filetype !~? 'help' && &readonly ? ' RO' : '') . (&modifiable && &modified ? ' +' : '')
  if g:ll_filename !=# ''
    let l:total_len += strlen(g:ll_filename) + 2
    if l:ww < l:total_len
      let g:ll_filename = ''
      return ''
    endif
  endif

  let g:ll_fileinfo = &fileformat . ' ' . (strlen(&fileencoding) ? &fileencoding : &encoding) . ' ' . (strlen(&filetype) ? &filetype : 'no')
  if g:ll_fileinfo !=# ''
    let l:total_len += strlen(g:ll_fileinfo) + 2
    if l:ww < l:total_len
      let g:ll_fileinfo = ''
      return ''
    endif
  endif

  let g:ll_ale = LLGetAle()
  if g:ll_ale !=# ''
    let l:total_len += strlen(g:ll_ale) + 2
    if l:ww < l:total_len
      let g:ll_ale = ''
      return ''
    endif
  endif

  let g:ll_fugitive = exists('*fugitive#head') ? fugitive#head() : ''
  if g:ll_fugitive !=# ''
    let l:total_len += strlen(g:ll_fugitive) + 2
    if l:ww < l:total_len
      let g:ll_fugitive = ''
      return ''
    endif
  endif

  return ''
endfunction

function! LLMode()
  return g:ll_mode
endfunction

function! LLFileName()
  return g:ll_filename
endfunction

function! LLFugitive()
  return g:ll_fugitive
endfunction

function! LLFileInfo()
  return g:ll_fileinfo
endfunction

function! LLLineInfo()
  return g:ll_lineinfo
endfunction

function! LLAle()
  return g:ll_ale
endfunction

if dein#tap('ale')
  function! LLGetAle()
    let l:count = ale#statusline#Count(bufnr(''))
    let l:errors = l:count.error + l:count.style_error
    let l:warnings = l:count.warning + l:count.style_warning
    return l:count.total == 0 ? 'OK' : 'E:' . l:errors . ' W:' . l:warnings
  endfunction
else
  function! LLGetAle()
    return ''
  endfunction
endif

'''
[[plugins]]
repo = 'taohexxx/lightline-buffer'
depends = 'itchyny/lightline.vim'
hook_add = '''
" lightline-buffer ui settings
" enable devicons, only support utf-8
" require <https://github.com/ryanoasis/vim-devicons>
let g:lightline_buffer_enable_devicons = 1

" lightline-buffer function settings
let g:lightline_buffer_show_bufnr = 0

" :help filename-modifiers
let g:lightline_buffer_fname_mod = ':t'

" hide buffer list
let g:lightline_buffer_excludes = ['vimfiler']

" max file name length
let g:lightline_buffer_maxflen = 30

" max file extension length
let g:lightline_buffer_maxfextlen = 3

" min file name length
let g:lightline_buffer_minflen = 16

" min file extension length
let g:lightline_buffer_minfextlen = 3

" reserve length for other component (e.g. info, close)
let g:lightline_buffer_reservelen = 20
'''
# }}}
